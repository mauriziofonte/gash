#!/usr/bin/env bash

# Bash completion for Gash functions

# Ensure that Gash functions are available by checking for one core Gash function.
if ! declare -f git_add_tag >/dev/null 2>&1; then
    return
fi

# -----------------------------------------------------------------------------
# Internal Helpers
# -----------------------------------------------------------------------------

# Check if a function name should be excluded from public list.
# Returns 0 (true) if should be excluded, 1 (false) if should be included.
__gash_is_internal_function() {
    local fn="${1-}"
    [[ -z "$fn" ]] && return 0

    case "$fn" in
        __*|_*)
            return 0
            ;;
        needs_help|needs_confirm_prompt|print_error)
            return 0
            ;;
    esac

    return 1
}

# Build a whitespace-separated list of "public" Gash functions.
# Prefer __GASH_ADDED_FUNCS (computed by gash.sh) so we don't include user-defined functions.
__gash_public_functions() {
    local out=""
    local fn

    if [[ -n "${__GASH_ADDED_FUNCS-}" ]]; then
        local IFS=$'\n'
        for fn in ${__GASH_ADDED_FUNCS}; do
            __gash_is_internal_function "$fn" && continue
            out+="$fn "
        done

        printf '%s' "${out% }"
        return 0
    fi

    # Fallback: keep a minimal set if we can't detect the added functions.
    printf '%s' "disk_usage files_largest dirs_largest dirs_find_large history_grep git_add_tag git_delete_tag"
}

# Build a whitespace-separated list of short aliases for Gash functions.
__gash_short_aliases() {
    local out=""
    local al

    if [[ -n "${__GASH_ADDED_ALIASES-}" ]]; then
        local IFS=$'\n'
        for al in ${__GASH_ADDED_ALIASES}; do
            [[ -z "${al-}" ]] && continue
            out+="$al "
        done

        printf '%s' "${out% }"
        return 0
    fi

    # Fallback: short aliases for common functions
    printf '%s' "du2 flf dld dfl hg gat gdt glt gdr gap dsa daa dpa pf pk ptk svs plz mkcd axe fbk dle myip"
}

# -----------------------------------------------------------------------------
# Completion Function
# -----------------------------------------------------------------------------

# Completion function for Gash
__gash_complete() {
    local current_word previous_word

    current_word="${COMP_WORDS[COMP_CWORD]}"

    # COMP_CWORD can be 0 in some edge cases; avoid negative indexes (bash 3 compatibility).
    if (( COMP_CWORD > 0 )); then
        previous_word="${COMP_WORDS[COMP_CWORD - 1]}"
    else
        previous_word=""
    fi

    # Define Gash commands (public functions + short aliases)
    local commands
    commands="$(__gash_public_functions) $(__gash_short_aliases)"

    case "${previous_word}" in
        # For git tag functions, check if in git repo and suggest tags accordingly
        git_add_tag|git_delete_tag|git_list_tags|gat|gdt|glt)
            if type -P git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
                # git tags are whitespace-free in normal usage; compgen uses $IFS splitting.
                COMPREPLY=($(compgen -W "$(git tag -l 2>/dev/null)" -- "${current_word}"))
            else
                COMPREPLY=()
            fi
            ;;
        # For Gash commands, suggest available functions
        *)
            COMPREPLY=($(compgen -W "${commands}" -- "${current_word}"))
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Enable Completion
# -----------------------------------------------------------------------------

# Activate completion for each public Gash function and alias
__gash_enable_completion() {
    local fn
    local al

    # Register completion for public functions
    if [[ -n "${__GASH_ADDED_FUNCS-}" ]]; then
        local IFS=$'\n'
        for fn in ${__GASH_ADDED_FUNCS}; do
            __gash_is_internal_function "$fn" && continue
            complete -o default -F __gash_complete "$fn"
        done
    else
        # Fallback registration for functions
        complete -o default -F __gash_complete git_add_tag
        complete -o default -F __gash_complete git_delete_tag
        complete -o default -F __gash_complete git_list_tags
        complete -o default -F __gash_complete disk_usage
        complete -o default -F __gash_complete files_largest
        complete -o default -F __gash_complete dirs_largest
        complete -o default -F __gash_complete dirs_find_large
        complete -o default -F __gash_complete history_grep
    fi

    # Register completion for short aliases
    if [[ -n "${__GASH_ADDED_ALIASES-}" ]]; then
        local IFS=$'\n'
        for al in ${__GASH_ADDED_ALIASES}; do
            [[ -z "${al-}" ]] && continue
            complete -o default -F __gash_complete "$al"
        done
    else
        # Fallback registration for aliases
        local alias_list="du2 flf dld dfl hg gat gdt glt gdr gap dsa daa dpa pf pk ptk svs plz mkcd axe fbk dle myip"
        for al in $alias_list; do
            complete -o default -F __gash_complete "$al"
        done
    fi
}

__gash_enable_completion
unset -f __gash_enable_completion

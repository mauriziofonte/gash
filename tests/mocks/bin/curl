#!/usr/bin/env bash

# Mock curl for testing AI module and Docker registry API.
# Simulates Claude/Gemini API responses and Docker registry endpoints.

# Track calls for verification (optional)
if [[ -n "${MOCK_CURL_LOG:-}" ]]; then
    echo "curl $*" >> "$MOCK_CURL_LOG"
fi

# Parse arguments - look for URL and body in all arguments
url=""
http_code_output=""
output_file=""
request_body=""
is_head_request=0

# Store all args for scanning
all_args=("$@")

# Scan for specific args
i=0
while [[ $i -lt ${#all_args[@]} ]]; do
    arg="${all_args[$i]}"
    case "$arg" in
        -w)
            ((i++))
            http_code_output="${all_args[$i]:-}"
            ;;
        -o)
            ((i++))
            output_file="${all_args[$i]:-}"
            ;;
        -d)
            ((i++))
            request_body="${all_args[$i]:-}"
            ;;
        -I)
            is_head_request=1
            ;;
        http*|https*)
            url="$arg"
            ;;
    esac
    ((i++))
done

# Determine response type based on query content in body
# Priority: troubleshoot > command > explanation > code > fallback
# Note: We extract only the user query (after Context JSON) to avoid matching system prompt text
detect_response_type() {
    local body="$1"

    # Extract user query: it comes after "}\\n\\n" (end of context JSON + double newline)
    # The pattern in the JSON is: "content": "Context: {...}\n\nUSER_QUERY"
    local user_query
    user_query=$(echo "$body" | sed -n 's/.*}\\n\\n\([^"]*\)".*/\1/p' | head -1)
    local lower_query
    lower_query=$(echo "$user_query" | tr '[:upper:]' '[:lower:]')

    # Only "[PIPE INPUT" triggers troubleshoot
    if [[ "$lower_query" == *"[pipe input"* ]]; then
        echo "troubleshoot"
    elif [[ "$lower_query" == *"how to"* ]] || [[ "$lower_query" == *"come faccio"* ]] || [[ "$lower_query" == *"how do i"* ]]; then
        echo "command"
    elif [[ "$lower_query" == *"what is"* ]] || [[ "$lower_query" == *"cos'Ã¨"* ]] || [[ "$lower_query" == *"explain"* ]] || [[ "$lower_query" == *"spiega"* ]]; then
        echo "explanation"
    elif [[ "$lower_query" == *"write a script"* ]] || [[ "$lower_query" == *"scrivi uno script"* ]] || [[ "$lower_query" == *"write code"* ]]; then
        echo "code"
    else
        echo "fallback"
    fi
}

# Generate inner JSON based on response type
generate_inner_json() {
    local resp_type="$1"
    case "$resp_type" in
        troubleshoot)
            echo '{"type":"troubleshoot","issue":"PHP Fatal error - undefined variable","suggestion":"Check variable initialization before use","text":"Analysis complete"}'
            ;;
        command)
            echo '{"type":"command","command":"ls -lhS","text":"Lists files sorted by size in descending order."}'
            ;;
        explanation)
            echo '{"type":"explanation","text":"This is a conceptual explanation of the topic."}'
            ;;
        code)
            echo '{"type":"code","text":"Creates a backup script.","code":"#!/bin/bash\\ntar -czf backup.tar.gz ~/","lang":"bash"}'
            ;;
        fallback|*)
            echo '{"type":"fallback","text":"I am a bash/linux terminal assistant. How can I help?"}'
            ;;
    esac
}

# Determine response based on URL
response=""
http_code="200"

# Check for simulated errors (global, applies to any URL)
if [[ -n "${MOCK_CURL_ERROR:-}" ]]; then
    http_code="500"
    response='{"error":{"message":"Simulated error"}}'
elif [[ -n "${MOCK_CURL_TIMEOUT:-}" ]]; then
    # Simulate timeout - exit with curl timeout code
    exit 28

# --- Docker Registry Endpoints ---
elif [[ "$url" == *"auth.docker.io/token"* ]]; then
    # Docker Hub auth token endpoint
    if [[ "${MOCK_CURL_REGISTRY_AUTH_FAIL:-}" == "1" ]]; then
        http_code="500"
        response='{"error":"internal_error"}'
    elif [[ "${MOCK_CURL_REGISTRY_UNAUTHORIZED:-}" == "1" ]]; then
        http_code="401"
        response='{"errors":[{"code":"UNAUTHORIZED","message":"authentication required"}]}'
    else
        response='{"token":"mock-dockerhub-token-abc123","access_token":"mock-dockerhub-token-abc123"}'
        http_code="200"
    fi

elif [[ "$url" == *"ghcr.io/token"* ]]; then
    # GHCR auth token endpoint
    if [[ "${MOCK_CURL_REGISTRY_AUTH_FAIL:-}" == "1" ]]; then
        http_code="500"
        response='{"error":"internal_error"}'
    else
        response='{"token":"mock-ghcr-token-xyz789"}'
        http_code="200"
    fi

elif [[ "$url" == *"/v2/"*"/manifests/"* ]]; then
    # Registry manifest endpoint (Docker Hub, GHCR, or generic)
    if [[ "${MOCK_CURL_REGISTRY_TIMEOUT:-}" == "1" ]]; then
        exit 28
    elif [[ "${MOCK_CURL_REGISTRY_RATE_LIMITED:-}" == "1" ]]; then
        http_code="429"
        response='{"errors":[{"code":"TOOMANYREQUESTS","message":"rate limit exceeded"}]}'
    elif [[ "${MOCK_CURL_REGISTRY_NOT_FOUND:-}" == "1" ]]; then
        http_code="404"
        response='{"errors":[{"code":"MANIFEST_UNKNOWN","message":"manifest unknown"}]}'
    elif [[ "${MOCK_CURL_REGISTRY_UNAUTHORIZED:-}" == "1" ]]; then
        http_code="401"
        response='{"errors":[{"code":"UNAUTHORIZED","message":"authentication required"}]}'
    else
        # Success: return mock digest in headers (for HEAD requests) or body
        http_code="200"
        if [[ $is_head_request -eq 1 ]]; then
            response=$'HTTP/2 200\r\ncontent-type: application/vnd.docker.distribution.manifest.v2+json\r\ndocker-content-digest: sha256:newdigest456abc123def456abc123def456abc123def456abc123def456newdig\r\n'
        else
            response='{"schemaVersion":2,"mediaType":"application/vnd.docker.distribution.manifest.v2+json"}'
        fi
    fi

# --- AI API Endpoints ---
elif [[ "$url" == *"api.anthropic.com"* ]]; then
    # Claude API response with structured JSON output
    resp_type=$(detect_response_type "$request_body")
    inner_json=$(generate_inner_json "$resp_type")
    # Escape inner JSON for embedding
    escaped_inner=$(echo "$inner_json" | sed 's/"/\\"/g')
    response='{"content":[{"text":"'"$escaped_inner"'"}],"model":"claude-haiku-4-5-20251001","stop_reason":"end_turn"}'
elif [[ "$url" == *"generativelanguage.googleapis.com"* ]]; then
    # Gemini API response with structured JSON output
    resp_type=$(detect_response_type "$request_body")
    inner_json=$(generate_inner_json "$resp_type")
    # Escape inner JSON for embedding
    escaped_inner=$(echo "$inner_json" | sed 's/"/\\"/g')
    response='{"candidates":[{"content":{"parts":[{"text":"'"$escaped_inner"'"}]}}]}'
else
    # Unknown URL - still return something for debugging
    http_code="404"
    response='{"error":"Unknown endpoint","url":"'"$url"'"}'
fi

# Write response to output file if specified
if [[ -n "$output_file" ]]; then
    echo "$response" > "$output_file"
fi

# Output HTTP code if requested
if [[ "$http_code_output" == "%{http_code}" ]]; then
    echo "$http_code"
fi

# If no output file and no http_code_output, print response to stdout
if [[ -z "$output_file" && -z "$http_code_output" ]]; then
    echo "$response"
fi

exit 0
